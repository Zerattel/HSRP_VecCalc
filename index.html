<!DOCTYPE html>
<html>
<head>
  <title>HSRP Vector Assistant</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: 'Exo 2', sans-serif;
    }

    #coordinateField {
      width: 70%;
      float: right;
      position: absolute;
      top: 0;
      right: 0;
    }

    /* Add the same style for other elements as needed */

  </style>
</head>
<body>
  <h1>HSRP Vector Assistant</h1>

  <div id="field">
    <button onclick="createBody()">Create Body</button>
    <button onclick="applyChangesToBody()">Apply</button>
    <br>
    <label for="bodyId">Body ID:</label>
    <input type="text" id="bodyId">
    <br>
    <label for="xCoord">X Coordinate (m):</label>
    <input type="text" id="xCoord">
    <br>
    <label for="yCoord">Y Coordinate (m):</label>
    <input type="text" id="yCoord">
    <br>
    <label for="course">Course (degrees):</label>
    <input type="text" id="course">
    <br>
    <label for="speed">Speed (m/s):</label>
    <input type="text" id="speed">
    <br>
    <label for="color">C:</label>
    <select id="color">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="green">Green</option>
      <option value="yellow">Yellow</option>
      <option value="orange">Orange</option>
      <option value="purple">Purple</option>
      <option value="pink">Pink</option>
      <option value="cyan">Cyan</option>
      <option value="brown">Brown</option>
      <option value="black">Black</option>
      <option value="white">White</option>
      <option value="grey">Grey</option>
      <option value="lime">Lime</option>
      <option value="magenta">Magenta</option>
      <option value="teal">Teal</option>
      <option value="navy">Navy</option>
    </select>
    <label for="sprite">S:</label>
    <select id="sprite">
      <option value="https://i.imgur.com/cfvoVs3.png">–®–∞—Ç—Ç–ª</option>
      <option value="https://i.imgur.com/fU6GRcZ.png">–ö–æ—Ä–≤–µ—Ç</option>
      <option value="https://i.imgur.com/UBTHFZC.png">–§—Ä–µ–≥–∞—Ç</option>
      <option value="https://i.imgur.com/K4dAHbL.png">–ò–Ω–¥. —Ñ—Ä–µ–≥–∞—Ç</option>
      <option value="https://i.imgur.com/w3wcLgj.png">–≠—Å–º–∏–Ω–µ—Ü</option>
      <option value="https://i.imgur.com/f9BfEM5.png">–ë—É—Ä–æ–≤–∞—è –±–∞—Ä–∂–∞</option>
      <option value="https://i.imgur.com/zz7SG9B.png">–ò–Ω–¥. —Ñ–ª–∞–≥–º–∞–Ω</option>
      <option value="https://i.imgur.com/Uqg0Dvd.png">–ò–Ω–¥. –ö–ê–†</option>
      <option value="https://i.imgur.com/PNxogBn.png">–ö—Ä–µ–π—Å–µ—Ä</option>
      <option value="https://i.imgur.com/w3wcLgj.png">–õ–∏–Ω–µ–π–Ω—ã–π –∫—Ä–µ–π—Å–µ—Ä</option>
      <option value="https://i.imgur.com/fwQbLy9.png">–õ–∏–Ω–∫–æ—Ä</option>
      <option value="https://i.imgur.com/mQJoGUE.png">–ê–≤–∏–∞–Ω–æ—Å–µ—Ü</option>
      <option value="https://i.imgur.com/Ob7kuP1.png">–î—Ä–µ–¥–Ω–æ—É—Ç</option>
      <option value="https://i.imgur.com/YHteNXI.png">–¢–∏—Ç–∞–Ω</option>
      <option value="https://edassets.org/static/img/missions/assassin.png">–¶–µ–ª—å</option>
      <option value="https://edassets.org/static/img/power-related/Fortifying.png">–ó–∞—â–∏—Ç–∏—Ç—å</option>
      <option value="https://edassets.org/static/img/stations/Asteroid_Station_Icon.png">–ê—Å—Ç–µ—Ä—Å—Ç–∞–Ω—Ü–∏—è</option>
      <option value="https://edassets.org/static/img/stations/Orbis.png">–°—Ç–∞–Ω—Ü–∏—è</option>
      <option value="https://edassets.org/static/img/stations/Outpost.png">–ê–≤–∞–Ω–ø–æ—Å—Ç</option>
      <option value="https://edassets.org/static/img/power-ethos/Covert_border.png">–û–ø–∞—Å–Ω–æ—Å—Ç—å</option>
      <option value="https://edassets.org/static/img/missions/mining.png">–ê—Å—Ç–µ—Ä–æ–∏–¥</option>
      <option value="https://edassets.org/static/img/missions/planetary-data-unknown-mission.png">–ú–∞—è–∫</option>
      <option value="https://edassets.org/static/img/missions/unknown-mission.png">–ì–ª–∞–∑</option>
      <option value="https://edassets.org/static/img/missions/pirate-timed.png">–°–∏–≥–Ω–∞–ª</option>
      <option value="https://edassets.org/static/img/missions/rescue-mission.png">–û—Å—Ç–æ–≤</option>
      <option value="custom">Custom URL</option>
    </select>
    <input type="text" id="customSpriteUrl" placeholder="Enter sprite URL" style="display:none;">
    
    <label for="spriteSize">SS:</label>
    <input type="number" id="spriteSize" value="0.2" min="0.1" step="0.1">
    <br>
    <button onclick="setCoordinates()">Set Coordinates</button>
    <button onclick="setManeuver()">Set Maneuver</button>
    <button onclick="setAbsoluteVector()">Set Absolute Vector</button>
    <button onclick="moveBodies()">Move</button>
    <div id="scaleButtons">
      <button onclick="changeScale()">Change Scale</button>
      <button onclick="changeMapSize()">Change Map Size</button>
      <button onclick="deleteSelectedBody()">Delete</button>
      <button onclick="launchSubBody()">Launch Subbody</button>
    </div>
    <div id="saveLoadButtons">
      <button onclick="saveBattlefield()">Save</button>
      <button onclick="loadBattlefield()">Load</button>
      <button onclick="createZone()">Create Zone</button>
    </div>
  </div>

  <div id="coordinateField">
    <h2>Coordinate Field</h2>
    <canvas id="myCanvas" width="1280" height="720" onclick="selectBody(event)"></canvas>
  </div>

  <div id="infoField">
    <h2>Relative Information</h2>
    <div id="relativeInfo">
      <div id="relativeInfo1"></div>
      <div id="relativeInfo2"></div>
      <div id="relativeInfo3"></div>
      <div id="relativeInfo4"></div>
    </div>
  </div>

  <script>
    let bodies = [];
    let fieldSize = 5000; // 5 kilometers in meters
    let scale = 1; // Initial scale
    let canvasWidth = 1280; // Initial canvas width
    let canvasHeight = 720; // Initial canvas height
    let previousTime = Date.now(); // For calculating delta time

    function createBody() {
        let bodyId = document.getElementById('bodyId').value;
        let color = document.getElementById('color').value;
        let sprite = document.getElementById('sprite').value;
        let spriteSize = parseFloat(document.getElementById('spriteSize').value);
        let customSpriteUrl = sprite === 'custom' ? document.getElementById('customSpriteUrl').value : sprite;

        bodies.push({
          id: bodyId,
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          color: color,
          sprite: sprite,
          spriteSize: spriteSize,
          customSpriteUrl: customSpriteUrl
        });
        console.log("Body created: ", bodies);
      }

    function setCoordinates() {
      let bodyId = document.getElementById('bodyId').value;
      let xCoord = parseFloat(document.getElementById('xCoord').value);
      let yCoord = parseFloat(document.getElementById('yCoord').value);
      let body = bodies.find(b => b.id === bodyId);
      if (body) {
        body.x = xCoord;
        body.y = yCoord;
        console.log("Coordinates updated for body: ", bodyId);
      } else {
        console.error("Body not found: ", bodyId);
      }
    }

  function setManeuver() {
  let bodyId = document.getElementById('bodyId').value;
  let course = parseFloat(document.getElementById('course').value);
  let speed = parseFloat(document.getElementById('speed').value);
  let body = bodies.find(b => b.id === bodyId);
  if (body) {
    // Convert course to radians (0 degrees is now upwards)
    let courseRadians = (90 - course) * Math.PI / 180;
    let dvx = speed * Math.cos(courseRadians);
    let dvy = speed * Math.sin(courseRadians);
    
    // Add the new vector to the existing one
    body.vx += dvx;
    body.vy += dvy;

    console.log("Maneuver set for body: ", bodyId);
    console.log(`New vector: vx: ${body.vx}, vy: ${body.vy}`);
  } else {
    console.error("Body not found: ", bodyId);
  }
}

document.getElementById('sprite').addEventListener('change', function() {
        let customInput = document.getElementById('customSpriteUrl');
        customInput.style.display = this.value === 'custom' ? 'inline-block' : 'none';
      });

function setAbsoluteVector() {
  let bodyId = document.getElementById('bodyId').value;
  let course = parseFloat(document.getElementById('course').value);
  let speed = parseFloat(document.getElementById('speed').value);
  let body = bodies.find(b => b.id === bodyId);
  if (body) {
    // Convert course to radians (0 degrees is now upwards)
    let courseRadians = (90 - course) * Math.PI / 180;
    body.vx = speed * Math.cos(courseRadians);
    body.vy = speed * Math.sin(courseRadians);
    console.log("Absolute vector set for body: ", bodyId);
    console.log(`New vector: vx: ${body.vx}, vy: ${body.vy}`);
  } else {
    console.error("Body not found: ", bodyId);
  }
}

function applyChangesToBody() {
  let bodyId = document.getElementById('bodyId').value;
  let selectedBody = bodies.find(b => b.id === bodyId);
  
  if (!selectedBody) {
    alert("No body selected.");
    return;
  }

  selectedBody.color = document.getElementById('color').value;
  selectedBody.sprite = document.getElementById('sprite').value;
  selectedBody.spriteSize = parseFloat(document.getElementById('spriteSize').value);
  
  if (selectedBody.sprite === 'custom') {
    selectedBody.customSpriteUrl = document.getElementById('customSpriteUrl').value;
  }
}

function launchSubBody() {
  const parentBodyId = prompt("Enter the ID of the parent body:");
  const targetBodyId = prompt("Enter the ID of the target body:");
  const deltaVTotal = parseFloat(prompt("Enter total delta-V:"));
  const deltaVStep = parseFloat(prompt("Enter delta-V per step:"));

  const parentBody = bodies.find(b => b.id === parentBodyId);
  const targetBody = bodies.find(b => b.id === targetBodyId);

  if (!parentBody || !targetBody) {
    console.error("Invalid body IDs provided.");
    return;
  }

  const subBodyId = `SB_${parentBodyId}_${Math.floor(Math.random() * 1000)}`;
  const subBody = {
    id: subBodyId,
    x: parentBody.x,
    y: parentBody.y,
    vx: parentBody.vx,
    vy: parentBody.vy,
    color: parentBody.color,
    deltaVRemaining: deltaVTotal,
    deltaVStep: deltaVStep,
    targetId: targetBodyId,
    sprite: "https://edassets.org/static/img/cqc/Flag-hologram.png",
    spriteSize: 0.025,
    previousDistance: null, // –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ overshoot
  };

  bodies.push(subBody);
  }


    function deleteBody(bodyId) {
      bodies = bodies.filter(b => b.id !== bodyId);
      console.log(`Body ${bodyId} deleted.`);
    }


let moveTimeout;

function moveBodies() {
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw grid
  drawGrid(ctx, canvasWidth, canvasHeight);

  const currentTime = Date.now();
  const deltaTime = Math.min((currentTime - previousTime) / 1000, 1.0); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º deltaTime
  previousTime = currentTime;

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
  bodies.forEach(body => {
    body.previousX = body.x;
    body.previousY = body.y;
  });

  bodies.forEach(body => {
    // –ï—Å–ª–∏ —ç—Ç–æ —Å—É–±—Ç–µ–ª–æ, –≤—ã–ø–æ–ª–Ω—è–µ–º –º–∞–Ω—ë–≤—Ä—ã
    if (body.id.startsWith("SB_") && body.deltaVRemaining > 0) {
      const target = bodies.find(b => b.id === body.targetId);
      if (target) {
        const dx = target.x - body.x;
        const dy = target.y - body.y;
        const angleToTarget = Math.atan2(dy, dx);
        const relativeVx = body.vx - target.vx;
        const relativeVy = body.vy - target.vy;

        // –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
        const transverseVelocity = relativeVx * Math.sin(angleToTarget) - relativeVy * Math.cos(angleToTarget);

        // –†–∞—Å—á—ë—Ç –º–∞–Ω—ë–≤—Ä–∞
        const transverseCorrectionX = -transverseVelocity * Math.sin(angleToTarget);
        const transverseCorrectionY = transverseVelocity * Math.cos(angleToTarget);
        const maneuverVx = body.deltaVStep * Math.cos(angleToTarget) + transverseCorrectionX;
        const maneuverVy = body.deltaVStep * Math.sin(angleToTarget) + transverseCorrectionY;

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞–Ω—ë–≤—Ä
        body.vx += maneuverVx;
        body.vy += maneuverVy;
        body.deltaVRemaining -= body.deltaVStep;

        console.log(`Subbody ${body.id} performed a maneuver. Remaining delta-V: ${body.deltaVRemaining}`);
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–µ–ª–∞
    body.x += body.vx * deltaTime;
    body.y += body.vy * deltaTime;
  });

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Ç–æ–≥–æ–≤ –∑–∞–ø—É—Å–∫–∞ —Å—É–±—Ç–µ–ª
  bodies.forEach(body => {
    if (body.id.startsWith("SB_")) {
      const target = bodies.find(b => b.id === body.targetId);
      if (target) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–π
        if (checkLineIntersection(body, target)) return;

        // –ï—Å–ª–∏ –¥–µ–ª—å—Ç–∞-V –∏—Å—á–µ—Ä–ø–∞–Ω–æ, –Ω–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç
        if (body.deltaVRemaining <= 0) {
          body.despawnCountdown = (body.despawnCountdown || 3) - 1;

          if (body.despawnCountdown <= 0) {
            alert(`Subbody ${body.id} missed target ${target.id}.`);
            console.log(`Subbody ${body.id} missed target ${target.id}.`);
            deleteBody(body.id);
          }
        }
      }
    }
  });

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–µ–ª
  bodies.forEach(body => {
          const bodyX = canvas.width / 2 + (body.x / fieldSize) * canvas.width;
          const bodyY = canvas.height / 2 - (body.y / fieldSize) * canvas.height;
          let spriteUrl = body.sprite === 'custom' ? body.customSpriteUrl : body.sprite;
          let size = body.spriteSize || 1;
          let angle = Math.atan2(body.vy, body.vx) * 180 / Math.PI;
          let color = body.color || 'white';
          
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–ø—Ä–∞–π—Ç–∞ —Å –æ–∫—Ä–∞—Å–∫–æ–π –±–µ–∑ –≤–ª–∏—è–Ω–∏—è –Ω–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –¥—Ä—É–≥–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
          let img = new Image();
          img.onload = function() {
            let bufferCanvas = document.createElement('canvas');
            let bufferCtx = bufferCanvas.getContext('2d');
            bufferCanvas.width = img.width;
            bufferCanvas.height = img.height;

            bufferCtx.drawImage(img, 0, 0);
            bufferCtx.globalCompositeOperation = 'source-atop';
            bufferCtx.fillStyle = color;
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufferCtx.globalCompositeOperation = 'source-over';
            
            ctx.save();
            ctx.translate(bodyX, bodyY);
            if (body.vx !== 0 || body.vy !== 0) {
              ctx.rotate((90 - angle) * Math.PI / 180);
            }
            ctx.drawImage(bufferCanvas, -img.width * size / 2, -img.height * size / 2, img.width * size, img.height * size);
            ctx.restore();
          };
          img.src = spriteUrl;
          
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞
          ctx.fillStyle = color;
          ctx.font = '14px "Exo 2", sans-serif';
          let textOffsetY = -15 + (img.height * (size * 0.75));
          let textWidth = ctx.measureText(body.id).width;
          ctx.fillText(body.id, bodyX - textWidth / 2, bodyY - textOffsetY);
          
          if (body.vx !== 0 || body.vy !== 0) {
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤–µ–∫—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è –∫–∞–∫ —Å—Ç—Ä–µ–ª–∫–∏
          let nextX = body.x + body.vx;
          let nextY = body.y + body.vy;
          let vectorEndX = canvas.width / 2 + (nextX / fieldSize) * canvas.width;
          let vectorEndY = canvas.height / 2 - (nextY / fieldSize) * canvas.height;
          
          ctx.beginPath();
          ctx.globalAlpha = 0.4;
          ctx.moveTo(bodyX, bodyY);
          ctx.lineTo(vectorEndX, vectorEndY);
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–∫–æ–Ω–µ—á–Ω–∏–∫–∞ —Å—Ç—Ä–µ–ª–∫–∏
          let arrowSize = 10;
          let arrowAngle = Math.atan2(vectorEndY - bodyY, vectorEndX - bodyX);
          ctx.beginPath();
          ctx.globalAlpha = 0.4;
          ctx.moveTo(vectorEndX, vectorEndY);
          ctx.lineTo(vectorEndX - arrowSize * Math.cos(arrowAngle - Math.PI / 6), vectorEndY - arrowSize * Math.sin(arrowAngle - Math.PI / 6));
          ctx.lineTo(vectorEndX - arrowSize * Math.cos(arrowAngle + Math.PI / 6), vectorEndY - arrowSize * Math.sin(arrowAngle + Math.PI / 6));
          ctx.lineTo(vectorEndX, vectorEndY);
          ctx.fillStyle = color;
          ctx.fill();
          
          // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ø–æ–ø–µ—Ä–µ—á–Ω–∞—è –ª–∏–Ω–∏—è –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ–∫—Ç–æ—Ä–µ
          let offset = 50;
          let normalAngle = arrowAngle + Math.PI / 2;
          let textX = (bodyX + vectorEndX) / 2 + offset * Math.cos(normalAngle);
          let textY = (bodyY + vectorEndY) / 2 + offset * Math.sin(normalAngle);
          
          ctx.beginPath();
          ctx.moveTo((bodyX + vectorEndX) / 2, (bodyY + vectorEndY) / 2);
          ctx.lineTo(textX, textY);
          ctx.strokeStyle = color;
          ctx.globalAlpha = 0.3;
          ctx.stroke();
          ctx.globalAlpha = 1.0;
          
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–µ–∫—Ç–æ—Ä–µ
          ctx.fillStyle = color;
          ctx.font = '9px "Exo 2", sans-serif';
          let speed = Math.sqrt(body.vx ** 2 + body.vy ** 2).toFixed(2);
          ctx.fillText(`V: ${speed} m/s`, textX, textY - 5);
          ctx.fillText(`C: ${angle.toFixed(2)}¬∞`, textX, textY + 10);
        }});
        
        drawZones(ctx);
        updateRelativeInfo();
      }

function drawZones(ctx) {
      bodies.forEach(body => {
        let bodyX = ctx.canvas.width / 2 + (body.x / fieldSize) * ctx.canvas.width;
        let bodyY = ctx.canvas.height / 2 - (body.y / fieldSize) * ctx.canvas.height;
        
        if (!body.zones || body.zones.length === 0) return;
        
        body.zones.forEach(zone => {
          let pixelRadius = (zone.radius / fieldSize) * ctx.canvas.width;
          ctx.beginPath();
          ctx.arc(bodyX, bodyY, pixelRadius, 0, 2 * Math.PI);
          ctx.strokeStyle = zone.color;
          ctx.globalAlpha = 0.25;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.globalAlpha = 1;
        });
      });
    }

function createZone() {
      let bodyId = document.getElementById('bodyId').value;
      let body = bodies.find(b => b.id === bodyId);
      if (!body) return alert("Body not found");
      
      if (!body.zones) body.zones = [];
      
      let zoneId = prompt("Enter zone identifier:");
      let color = prompt("Enter color (hex or name):");
      let radius = parseFloat(prompt("Enter radius in meters:"));
      
      if (body.zones.some(z => z.id === zoneId)) {
        body.zones = body.zones.filter(z => z.id !== zoneId);
      } else {
        body.zones.push({ id: zoneId, color, radius });
      }
    }


function getNearestPointOnLine(lineStart, lineEnd, point) {
  const lineDx = lineEnd.x - lineStart.x;
  const lineDy = lineEnd.y - lineStart.y;

  const t = ((point.x - lineStart.x) * lineDx + (point.y - lineStart.y) * lineDy) /
            (lineDx ** 2 + lineDy ** 2);

  // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º t –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ—Ç—Ä–µ–∑–∫–∞ [0, 1]
  const clampedT = Math.max(0, Math.min(1, t));

  return {
    x: lineStart.x + clampedT * lineDx,
    y: lineStart.y + clampedT * lineDy,
  };
}

function checkLineIntersection(subBody, target) {
  const subBodyStart = { x: subBody.previousX, y: subBody.previousY };
  const subBodyEnd = { x: subBody.x, y: subBody.y };
  const targetStart = { x: target.previousX, y: target.previousY };
  const targetEnd = { x: target.x, y: target.y };

  console.log(`Checking intersection for Subbody ${subBody.id} and Target ${target.id}`);
  console.log(`Subbody: Start (${subBodyStart.x}, ${subBodyStart.y}), End (${subBodyEnd.x}, ${subBodyEnd.y})`);
  console.log(`Target: Start (${targetStart.x}, ${targetStart.y}), End (${targetEnd.x}, ${targetEnd.y})`);

  const det = (subBodyEnd.x - subBodyStart.x) * (targetEnd.y - targetStart.y) -
              (subBodyEnd.y - subBodyStart.y) * (targetEnd.x - targetStart.x);

  if (det === 0) {
    console.log("Lines are parallel, no intersection.");
  } else {
    const lambda = ((targetEnd.y - targetStart.y) * (targetEnd.x - subBodyStart.x) +
                    (targetStart.x - targetEnd.x) * (targetEnd.y - subBodyStart.y)) / det;
    const gamma = ((subBodyStart.y - subBodyEnd.y) * (targetEnd.x - subBodyStart.x) +
                   (subBodyEnd.x - subBodyStart.x) * (targetEnd.y - subBodyStart.y)) / det;

    console.log(`Det: ${det}, Lambda: ${lambda}, Gamma: ${gamma}`);

    if (0 <= lambda && lambda <= 1 && 0 <= gamma && gamma <= 1) {
      console.log(`Subbody ${subBody.id} intersects with Target ${target.id}.`);
      alert(`Subbody ${subBody.id} hit target ${target.id}.`);
      deleteBody(subBody.id);
      return true;
    }
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –Ω–∞ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ —Å—É–±—Ç–µ–ª–∞
  const nearestPoint = getNearestPointOnLine(subBodyStart, subBodyEnd, { x: target.x, y: target.y });
  const distance = Math.sqrt((nearestPoint.x - target.x) ** 2 + (nearestPoint.y - target.y) ** 2);

  console.log(`Nearest Point: (${nearestPoint.x}, ${nearestPoint.y}), Distance to Target: ${distance}`);

  if (distance <= 200) {
    console.log(`Subbody ${subBody.id} hit target ${target.id} within radius.`);
    alert(`Subbody ${subBody.id} hit target ${target.id}.`);
    deleteBody(subBody.id);
    return true;
  }

  console.log("No intersection or radius hit detected.");
  return false;
}


function selectBody(event) {
  const canvas = document.getElementById('myCanvas');
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const clickedBody = bodies.find(body => {
    let bodyX = canvas.width / 2 + (body.x / fieldSize) * canvas.width;
    let bodyY = canvas.height / 2 - (body.y / fieldSize) * canvas.height;
    return Math.sqrt((x - bodyX) ** 2 + (y - bodyY) ** 2) < 10;
  });

  if (clickedBody) {
    document.getElementById('bodyId').value = clickedBody.id;
    document.getElementById('xCoord').value = clickedBody.x.toFixed(2);
    document.getElementById('yCoord').value = clickedBody.y.toFixed(2);
    
    let course = Math.atan2(clickedBody.vx, clickedBody.vy) * 180 / Math.PI;
    course = (course + 360) % 360;
    document.getElementById('course').value = course.toFixed(2);
    
    document.getElementById('speed').value = Math.sqrt(clickedBody.vx ** 2 + clickedBody.vy ** 2).toFixed(2);
    console.log(`Selected body: ${clickedBody.id}`);
    updateRelativeInfo();
  } else {
    // –ï—Å–ª–∏ —Ç–µ–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–∫–∏
    let worldX = ((x - canvas.width / 2) / canvas.width) * fieldSize;
    let worldY = ((canvas.height / 2 - y) / canvas.height) * fieldSize;
    
    document.getElementById('xCoord').value = worldX.toFixed(2);
    document.getElementById('yCoord').value = worldY.toFixed(2);
    console.log(`No body found. Coordinates set: X=${worldX.toFixed(2)}, Y=${worldY.toFixed(2)}`);
  }
}

let toggleStates = {}; // Object to store toggle states

      function updateRelativeInfo() {
      const bodyId = document.getElementById('bodyId').value;
      const body = bodies.find(b => b.id === bodyId);
      if (!body) return;

      const infoDiv = document.getElementById('relativeInfo');
      infoDiv.innerHTML = '';

      bodies.forEach(otherBody => {
        if (body.id === otherBody.id) return;

        const dx = otherBody.x - body.x;
        const dy = otherBody.y - body.y;
        const distance = Math.sqrt(dx ** 2 + dy ** 2);
        const relativeVx = otherBody.vx - body.vx;
        const relativeVy = otherBody.vy - body.vy;
        const relativeSpeed = Math.sqrt(relativeVx ** 2 + relativeVy ** 2);
        const transverseVelocity = (relativeVx * dy - relativeVy * dx) / (distance || 1);
        const angularVelocity = transverseVelocity / (distance || 1) * (180 / Math.PI);

        let direction = Math.atan2(dy, dx) * 180 / Math.PI;
        direction = (90 - direction + 360) % 360; // Convert to clockwise angle from up

        const infoItem = document.createElement('div');
        infoItem.className = 'relative-info-item';

        const header = document.createElement('div');
        header.className = 'relative-info-header';

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ —Å —Ç–µ–ª–æ–º, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º –∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏
        header.innerHTML = `
          <span style="cursor:pointer;color:${otherBody.color};" onclick="document.getElementById('bodyId').value='${otherBody.id}';updateRelativeInfo();">${otherBody.id}</span> - ${distance.toFixed(2)} m 
          <span style="cursor:pointer;" onclick="sendTargetInfo('${otherBody.id}')">üì§</span>
        `;

        const toggleIcon = document.createElement('span');
        const isOpen = toggleStates[otherBody.id] || false;
        toggleIcon.textContent = isOpen ? '‚ñ≤' : '‚ñº';
        toggleIcon.style.cursor = 'pointer';
        toggleIcon.onclick = () => {
          toggleStates[otherBody.id] = !toggleStates[otherBody.id];
          updateRelativeInfo(); // Re-render to apply state
        };

        header.appendChild(toggleIcon);

        const content = document.createElement('div');
        content.className = 'relative-info-content';
        content.style.display = isOpen ? 'block' : 'none';
        content.innerHTML = `
          <p>Relative Speed: ${relativeSpeed.toFixed(2)} m/s</p>
          <p>Angular Velocity: ${angularVelocity.toFixed(2)}¬∞/s</p>
          <p>Direction: ${direction.toFixed(2)}¬∞</p>
        `;

        infoItem.appendChild(header);
        infoItem.appendChild(content);
        infoDiv.appendChild(infoItem);
      });
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ü–µ–ª–∏
    function sendTargetInfo(targetId) {
  if (!Array.isArray(bodies) || bodies.length === 0) {
    console.error('No bodies data available');
    return;
  }
  const body = bodies.find(b => b.id === document.getElementById('bodyId').value);
  const target = bodies.find(b => b.id === targetId);
  if (!body || !target) return;

  const dx = target.x - body.x;
  const dy = target.y - body.y;
  const distance = Math.sqrt(dx ** 2 + dy ** 2);
  const relativeVx = target.vx - body.vx;
  const relativeVy = target.vy - body.vy;
  const relativeSpeed = Math.sqrt(relativeVx ** 2 + relativeVy ** 2);
  const transverseVelocity = (relativeVx * dy - relativeVy * dx) / (distance || 1);
  const angularVelocity = transverseVelocity / (distance || 1) * (180 / Math.PI);

  let direction = Math.atan2(dy, dx) * 180 / Math.PI;
  direction = (90 - direction + 360) % 360; // Convert to clockwise angle from up

  const targetInfo = {
    id: target.id,
    distance: distance.toFixed(2),
    relativeSpeed: relativeSpeed.toFixed(2),
    angularVelocity: angularVelocity.toFixed(2),
    direction: direction.toFixed(2),
  };

  console.log('–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ü–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞:', targetInfo);
  alert(`–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ü–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞:\nID: ${targetInfo.id}\nDistance: ${targetInfo.distance} m\nRelative Speed: ${targetInfo.relativeSpeed} m/s\nAngular Velocity: ${targetInfo.angularVelocity}¬∞/s\nDirection: ${targetInfo.direction}¬∞`);

  fetch('https://script.google.com/macros/s/AKfycbxkj_vtMZj7yVUFZmMMpDyyGGibEUL9EIRMyguVGdEsNN4Acv-sWUtxSEjsFTST31j9/exec', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(targetInfo),
  mode: 'no-cors'  // –ò—Å–ø–æ–ª—å–∑—É–µ–º no-cors –¥–ª—è –æ–±—Ö–æ–¥–∞ CORS
})
  .then(response => {
    console.log('–û—Ç–≤–µ—Ç –æ—Ç Apps Script:', response);
  })
  .catch(error => console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö:', error));

}
function drawGrid(ctx, canvasWidth, canvasHeight) {
  ctx.strokeStyle = 'gray';
  ctx.lineWidth = 1;
  const step = (canvasWidth / fieldSize) * 1000; // 1 –∫–º –≤ –∏–≥—Ä–æ–≤–æ–º –º–∏—Ä–µ
  
  for (let x = 0; x < canvasWidth; x += step) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvasHeight);
    ctx.stroke();
  }
  for (let y = 0; y < canvasHeight; y += step) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvasWidth, y);
    ctx.stroke();
  }
}

    function changeScale() {
      let newScale = parseFloat(prompt("Enter new scale:"));
      scale = newScale;
      canvasWidth = 1280 * scale;
      canvasHeight = 720 * scale;

      // Resize the canvas
      const canvas = document.getElementById('myCanvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Redraw the bodies
      moveBodies();
    }

    function changeMapSize() {
  let newSize = parseFloat(prompt("Enter new map size in meters:"));
  if (isNaN(newSize) || newSize <= 0) {
    alert("Invalid map size.");
    return;
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –º–µ—Ç—Ä–∞—Ö –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º fieldSize
  bodies.forEach(body => {
    body.x = (body.x / fieldSize) * fieldSize;
    body.y = (body.y / fieldSize) * fieldSize;
  });

  fieldSize = newSize;
  moveBodies(); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞
}

    function saveBattlefield() {
  const saveData = {
    bodies: bodies,
    fieldSize: fieldSize,
    scale: scale
  };
  const data = JSON.stringify(saveData);
  const blob = new Blob([data], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'battlefield_save.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function loadBattlefield() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = (event) => {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const saveData = JSON.parse(e.target.result);
        bodies = saveData.bodies;
        fieldSize = saveData.fieldSize;
        scale = saveData.scale;
        
        // Update canvas size based on loaded scale
        canvasWidth = 1280 * scale;
        canvasHeight = 720 * scale;
        const canvas = document.getElementById('myCanvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        moveBodies(); // Redraw the battlefield
        console.log('Battlefield loaded successfully');
      } catch (error) {
        console.error('Error parsing the file:', error);
        alert('Error loading the file. Please make sure it\'s a valid battlefield save file.');
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function deleteSelectedBody() {
    let bodyId = document.getElementById('bodyId').value;
    if (!bodyId) {
        alert("–í–≤–µ–¥–∏—Ç–µ ID —Ç–µ–ª–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.");
        return;
    }
    
    let bodyIndex = bodies.findIndex(b => b.id === bodyId);
    if (bodyIndex === -1) {
        alert("–¢–µ–ª–æ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.");
        return;
    }

    bodies.splice(bodyIndex, 1);
    console.log(`–¢–µ–ª–æ ${bodyId} —É–¥–∞–ª–µ–Ω–æ.`);
    moveBodies(); // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç—Ä–∏—Å–æ–≤–∫—É
}

  </script>
</body>
</html>
